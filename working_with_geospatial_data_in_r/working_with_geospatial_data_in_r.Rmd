---
title: "Working with Geospatial Data in R"
author: "Jeff Li"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: true
    toc_depth: 3
    toc_float: true
---

"I maintained my edge by always being a student; you will always have something new to learn". - Jackie Joyner Kersee


Course Description: 

"Where should you buy a house to get the most value for your money? Your first step might be to make a map, but spatial analysis in R can be intimidating because of the complicated objects the data often live in.

This course will introduce you to spatial data by starting with objects you already know about, data frames, before introducing you to the special objects from the sp and raster packages used to represent spatial data for analysis in R. You'll learn to read, explore, and manipulate these objects with the big payoff of being able to use the tmap package to make maps.

By the end of the course you will have made maps of property sales in a small town, populations of the countries of the world, the distribution of people in the North East of the USA, and median income in the neighborhoods of New York City. "



Ref: Wickham, Charlotte. 2019. https://www.datacamp.com/.



Note: Some course materials have been adapted for my company training. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(ggmap)
```


# 1. Basic mapping with ggplot2 and ggmap 

"We'll dive in by displaying some spatial data -- property sales in a small US town -- using ggplot2 and we'll introduce you to the ggmap package as a quick way to add spatial context to your plots. We'll talk about what makes spatial data special and introduce you to the common types of spatial data we'll be working with throughout the course."


## 1.1 Introduction to spatial data 

What is spatial data? 

* Data are associated with locations

* Locations described by coordinates + a coordinate reference system (CRS)

* Commom CRS: longitude, latitude describes locations on the surface of the Earth. 


Point data: 

locations are points, described by single pair of coordinates

### 1.1.1 Grabbing a background map 

There are two steps to add a mpa to a *ggplot2* plot with *ggmap*: 

* 1. Download a map using *get_map()*

* 2. Display the map using *ggmap()* 


*get_map()* has a number of arguments that control what kind of map to get. 

```{r}
# a location 
register_google(key = Sys.getenv("register_google_api")) 

visalia <- c(lon = -119.2921, lat = 36.3302 )

# get map at zoon level 5: map - 5
map_5 <- get_map(visalia, zoom = 5, scale = 1)

# plot map at zoom level 5
ggmap(map_5) 

# get map at zoom level 13: visalia_map

visalia_map <- get_map(visalia, zoom = 13, scale = 2)

# plot map at zoom level 13

ggmap(visalia_map)

```


```{r}
library(ggmap)

register_google(key = Sys.getenv("register_google_api")) 

ggmap(get_googlemap())


corvallis <- c(lon = -123.2620, lat = 44.5646)

# Get map at zoom level 5: map_5
map_5 <- get_map(corvallis, zoom = 5, scale = 1)

# Plot map at zoom level 5
ggmap(map_5)

# Get map at zoom level 13: corvallis_map
corvallis_map <- get_map(corvallis, zoom = 13, scale = 1)

# Plot map at zoom level 13
ggmap(corvallis_map)
```


## 1.2 Options of get_map() and ggmap()

* maptype = c("terrain", "terrain-background", "satellite", "roadmap", "hybrid", "toner", "watercolor", "toner-2010", .. )

* source = c("google"," "osm", "stamen")

Specifying default data and aesthetics: 

* ggmap(ggmap, exten = "panel", base_layer, maprange = FALSE, legend = "right", padding = 0.02, darken = c(0, "black"), ...)

* one option: base_layer = ggplot(xx, aes(x, y))

```{r}
corvallis <- c(lon = -123.2620, lat = 44.5646)

# Add a maptype argument to get a satellite map
corvallis_map_sat <- get_map(corvallis, maptype = "satellite",  zoom = 13)

# Edit to display satellite map
ggmap(corvallis_map_sat) +
  geom_point(aes(lon, lat, color = year_built), data = sales)

# Add source and maptype to get toner map from Stamen Maps
corvallis_map_bw <- get_map(corvallis, source = "stamen", maptype = "toner", zoom = 13)

# Edit to display toner map
ggmap(corvallis_map_bw) +
  geom_point(aes(lon, lat, color = year_built), data = sales)
```

## 1.3 Leveraging *ggplot2's* strengths

By moving aes(x, y) and data from the initial geom_point() function to the ggplot() call within the ggmap() call, you can add facets, or extra layers, the usual ggplot2 way.

```{r}
# use base_layer argument ot ggmap() to specifiy data and x, y mappings
ggmap(corvallis_map_bw, base_layer = ggplot(data = sales, aes(x = lon, y = lat))) +
  geom_point(aes(col = class)) +
  facet_wrap(~class)

```

Using a base layer saves you from having repeated code when you have several geoms.

## 1.4 qmplot()

```{r}
# Plot house sales using qmplot()
# qmplot(x = lon, y = lat, data = sales, geom = "point", color = bedrooms) + 
#   facet_wrap( ~ month)
```

## 1.5 Types of spatial data

* point

* line

* polygon

* raster (a.k.a Gridded)


## 1.6 Drawing polygons

```{r}
dir("data/")

ward_sales <- read_rds("data/01_corv_wards.rds")

head(ward_sales)

# Add a point layer with color mapped to ward
ggplot(ward_sales, aes(lon, lat)) +
  geom_point(aes(color = ward))


# Add a point layer with color mapped to group
ggplot(ward_sales, aes(lon, lat)) +
  geom_point(aes(color = group))


# Add a path layer with group mapped to group
ggplot(ward_sales, aes(lon, lat)) +
  geom_path(aes(group = group))


# Add a polygon layer with fill mapped to ward, and group to group
ggplot(ward_sales, aes(lon, lat)) +
  geom_polygon(aes(fill = ward, group = group))
```


## 1.7 Choropleth Map 

```{r}
# Fix the polygon cropping
ggmap(corvallis_map_bw,extent = "normal", maprange = FALSE, 
      base_layer = ggplot(ward_sales, aes(lon, lat))) +
  geom_polygon(aes(group = group, fill = ward))

# Repeat, but map fill to num_sales
ggmap(corvallis_map_bw,extent = "normal", maprange = FALSE, 
      base_layer = ggplot(ward_sales, aes(lon, lat))) +
  geom_polygon(aes(group = group, fill = num_sales))

# Repeat again, but map fill to avg_price
ggmap(corvallis_map_bw,extent = "normal", maprange = FALSE, 
      base_layer = ggplot(ward_sales, aes(lon, lat))) +
  geom_polygon(aes(group = group, fill = avg_price), alpha = 0.8)
```


## 1.8 Raster data as a heatmap


```{r}
# Predicted house prices iin preds are raster data
preds <- read_rds("data/01_corv_predicted_grid.rds")
head(preds)

# Add a geom_point() layer
ggplot(preds, aes(lon, lat)) +
  geom_point()

# Add a tile layer with fill mapped to predicted_price
ggplot(preds, aes(lon, lat)) +
  geom_tile(aes(fill = predicted_price))

# Use ggmap() instead of ggplot()
ggmap(corvallis_map_bw) +
  geom_tile(aes(lon, lat, fill = predicted_price), 
            data = preds, alpha = 0.8)
```



# 2. Introducing *sp* objects

Why do we need a new object - *sp*? 

Because Data frames aren't a great way to store spatial data: 

* Need an easy way to keep coordinate reference system information

* Inefficient for complicated spatial objects

* Hierarchical structure gets forced into a flat structure 


The *sp* package: 

* provides classes for storing different types of spatial data

* provides methods for spatial objects, for manipulation

* is useful for point, line and polygon data 

* is a standard, so new spatial packages expect data in an *sp* object 


## 2.1 A spatial object - take a look 

```{r}
library(sp)

countries_sp <- read_rds("data/02_countries_sp.rds")

# Print countries_sp
# print(countries_sp)
class(countries_sp)


# Call summary() on countries_sp
summary(countries_sp)

# Call plot() on countries_sp
plot(countries_sp)
```


## 2.2 Waht's inside a spatial object? 

```{r}
# Call str() on countries_sp
#str(countries_sp)

# Call str() on countries_sp with max.level = 2
str(countries_sp, max.level = 2)
```


##  2.3 A more complicated spatial object

```{r}
# read data 
countries_spdf <- read_rds("data/02_countries_spdf.rds")

# Call summary() on countries_spdf and countries_sp
summary(countries_spdf)
summary(countries_sp)

# Call str() with max.level = 2 on countries_spdf
str(countries_spdf, max.level = 2)

# Plot countries_spdf
plot(countries_spdf)
```


## 2.4 Waling the hierarchy 

```{r}
# 169th element of countries_spdf@polygons: one
one <- countries_spdf@polygons[[169]]

# Print one
#one 

# Call summary() on one
summary(one)

# Call str() on one with max.level = 2
str(one, max.level = 2)


# str() with max.level = 2, on the Polygons slot of one
str(one@Polygons, max.level = 2)

# str() with max.level = 2, on the 6th element of the one@Polygons
str(one@Polygons[[6]])

# Call plot on the coords slot of 6th element of one@Polygons
plot(one@Polygons[[6]]@coords)


```


## 2.5 Subsetting by index

```{r}
# Subset the 169th object of countries_spdf: usa
usa <- countries_spdf[1, ]

# Look at summary() of usa
summary(usa)

# Look at str() of usa
str(usa, max.level = 2)

# Call plot() on usa
plot(usa)
```

## 2.6 Accessing data in sp objects 

```{r}
# Call head() and str() on the data slot of countries_spdf
head(countries_spdf@data)
str(countries_spdf@data)

# Pull out the name column using $
countries_spdf$name

# Pull out the subregion column using [[
countries_spdf[["subregion"]]
```


## 2.7 Subsetting based on data attributes

```{r}
# Create logical vector: is_nz
is_nz <- countries_spdf$name == "New Zealand"

# Subset countries_spdf using is_nz: nz
nz <- countries_spdf[is_nz, ]

# Plot nz
plot(nz)
```


## 2.7 tmap, a package that works with sp objects

```{r}
library(sp)
library(tmap)

# Use qtm() to create a choropleth map of gdp
qtm(shp = countries_spdf, fill = "gdp")

# Use qtm() to create a choropleth map of population
qtm(shp = countries_spdf, fill = "population")
```


## 2.8 Building a plot in layers

```{r}
# Add style argument to the tm_fill() call
tm_shape(countries_spdf) +
  tm_fill(col = "population", style = "quantile") +
    # Add a tm_borders() layer 
    tm_borders(col = "burlywood4")
  

# New plot, with tm_bubbles() instead of tm_fill()
tm_shape(countries_spdf) +
  tm_bubbles(size = "population", style = "quantile") +
    # Add a tm_borders() layer 
    tm_borders(col = "burlywood4")
```

## 2.9 Projection 

```{r}

# Switch to a Hobo–Dyer projection , designed to preserve area.
tm_shape(countries_spdf, projection = "hd") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") 

# Switch to a Robinson projection designed as a compromise between preserving local angles and area.
tm_shape(countries_spdf, projection = "robin") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") 

# Add tm_style_classic() to your plot

tm_shape(countries_spdf, projection = "robin") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") +
  tm_style_classic()

```


## 2.10 Save a tmap plot: static and interactive maps

```{r}

# Plot from last exercise
my_map <- tm_shape(countries_spdf) +
  tm_grid(n.x = 11, n.y = 11, projection = "longlat") +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4")

my_map

# Save a static version "population.png"
save_tmap(tm = my_map, filename = "population.png")

# Save an interactive version "population.html"
save_tmap(my_map, filename = "population.html")
```

