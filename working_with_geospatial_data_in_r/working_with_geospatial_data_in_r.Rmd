---
title: "Working with Geospatial Data in R"
author: "Jeff Li"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: true
    toc_depth: 3
    toc_float: true
---

"I maintained my edge by always being a student; you will always have something new to learn". - Jackie Joyner Kersee


Course Description: 

"Where should you buy a house to get the most value for your money? Your first step might be to make a map, but spatial analysis in R can be intimidating because of the complicated objects the data often live in.

This course will introduce you to spatial data by starting with objects you already know about, data frames, before introducing you to the special objects from the sp and raster packages used to represent spatial data for analysis in R. You'll learn to read, explore, and manipulate these objects with the big payoff of being able to use the tmap package to make maps.

By the end of the course you will have made maps of property sales in a small town, populations of the countries of the world, the distribution of people in the North East of the USA, and median income in the neighborhoods of New York City. "



Ref: Wickham, Charlotte. 2019. https://www.datacamp.com/.



Note: Some course materials have been adapted for my company training. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(ggmap)
```


# 1. Basic mapping with ggplot2 and ggmap 

"We'll dive in by displaying some spatial data -- property sales in a small US town -- using ggplot2 and we'll introduce you to the ggmap package as a quick way to add spatial context to your plots. We'll talk about what makes spatial data special and introduce you to the common types of spatial data we'll be working with throughout the course."


## 1.1 Introduction to spatial data 

What is spatial data? 

* Data are associated with locations

* Locations described by coordinates + a coordinate reference system (CRS)

* Commom CRS: longitude, latitude describes locations on the surface of the Earth. 


Point data: 

locations are points, described by single pair of coordinates

### 1.1.1 Grabbing a background map 

There are two steps to add a mpa to a *ggplot2* plot with *ggmap*: 

* 1. Download a map using *get_map()*

* 2. Display the map using *ggmap()* 


*get_map()* has a number of arguments that control what kind of map to get. 

```{r}
# a location 
register_google(key = Sys.getenv("register_google_api")) 

visalia <- c(lon = -119.2921, lat = 36.3302 )

# get map at zoon level 5: map - 5
map_5 <- get_map(visalia, zoom = 5, scale = 1)

# plot map at zoom level 5
ggmap(map_5) 

# get map at zoom level 13: visalia_map

visalia_map <- get_map(visalia, zoom = 13, scale = 2)

# plot map at zoom level 13

ggmap(visalia_map)

```


```{r}
library(ggmap)

register_google(key = Sys.getenv("register_google_api")) 

ggmap(get_googlemap())


corvallis <- c(lon = -123.2620, lat = 44.5646)

# Get map at zoom level 5: map_5
map_5 <- get_map(corvallis, zoom = 5, scale = 1)

# Plot map at zoom level 5
ggmap(map_5)

# Get map at zoom level 13: corvallis_map
corvallis_map <- get_map(corvallis, zoom = 13, scale = 1)

# Plot map at zoom level 13
ggmap(corvallis_map)
```


## 1.2 Options of get_map() and ggmap()

* maptype = c("terrain", "terrain-background", "satellite", "roadmap", "hybrid", "toner", "watercolor", "toner-2010", .. )

* source = c("google"," "osm", "stamen")

Specifying default data and aesthetics: 

* ggmap(ggmap, exten = "panel", base_layer, maprange = FALSE, legend = "right", padding = 0.02, darken = c(0, "black"), ...)

* one option: base_layer = ggplot(xx, aes(x, y))

```{r}
corvallis <- c(lon = -123.2620, lat = 44.5646)

# Add a maptype argument to get a satellite map
corvallis_map_sat <- get_map(corvallis, maptype = "satellite",  zoom = 13)

# Edit to display satellite map
ggmap(corvallis_map_sat) +
  geom_point(aes(lon, lat, color = year_built), data = sales)

# Add source and maptype to get toner map from Stamen Maps
corvallis_map_bw <- get_map(corvallis, source = "stamen", maptype = "toner", zoom = 13)

# Edit to display toner map
ggmap(corvallis_map_bw) +
  geom_point(aes(lon, lat, color = year_built), data = sales)
```

## 1.3 Leveraging *ggplot2's* strengths

By moving aes(x, y) and data from the initial geom_point() function to the ggplot() call within the ggmap() call, you can add facets, or extra layers, the usual ggplot2 way.

```{r}
# use base_layer argument ot ggmap() to specifiy data and x, y mappings
ggmap(corvallis_map_bw, base_layer = ggplot(data = sales, aes(x = lon, y = lat))) +
  geom_point(aes(col = class)) +
  facet_wrap(~class)

```

Using a base layer saves you from having repeated code when you have several geoms.

## 1.4 qmplot()

```{r}
# Plot house sales using qmplot()
# qmplot(x = lon, y = lat, data = sales, geom = "point", color = bedrooms) + 
#   facet_wrap( ~ month)
```

## 1.5 Types of spatial data

* point

* line

* polygon

* raster (a.k.a Gridded)


## 1.6 Drawing polygons

```{r}
dir("data/")

ward_sales <- read_rds("data/01_corv_wards.rds")

head(ward_sales)

# Add a point layer with color mapped to ward
ggplot(ward_sales, aes(lon, lat)) +
  geom_point(aes(color = ward))


# Add a point layer with color mapped to group
ggplot(ward_sales, aes(lon, lat)) +
  geom_point(aes(color = group))


# Add a path layer with group mapped to group
ggplot(ward_sales, aes(lon, lat)) +
  geom_path(aes(group = group))


# Add a polygon layer with fill mapped to ward, and group to group
ggplot(ward_sales, aes(lon, lat)) +
  geom_polygon(aes(fill = ward, group = group))
```


## 1.7 Choropleth Map 

```{r}
# Fix the polygon cropping
ggmap(corvallis_map_bw,extent = "normal", maprange = FALSE, 
      base_layer = ggplot(ward_sales, aes(lon, lat))) +
  geom_polygon(aes(group = group, fill = ward))

# Repeat, but map fill to num_sales
ggmap(corvallis_map_bw,extent = "normal", maprange = FALSE, 
      base_layer = ggplot(ward_sales, aes(lon, lat))) +
  geom_polygon(aes(group = group, fill = num_sales))

# Repeat again, but map fill to avg_price
ggmap(corvallis_map_bw,extent = "normal", maprange = FALSE, 
      base_layer = ggplot(ward_sales, aes(lon, lat))) +
  geom_polygon(aes(group = group, fill = avg_price), alpha = 0.8)
```


## 1.8 Raster data as a heatmap


```{r}
# Predicted house prices iin preds are raster data
preds <- read_rds("data/01_corv_predicted_grid.rds")
head(preds)

# Add a geom_point() layer
ggplot(preds, aes(lon, lat)) +
  geom_point()

# Add a tile layer with fill mapped to predicted_price
ggplot(preds, aes(lon, lat)) +
  geom_tile(aes(fill = predicted_price))

# Use ggmap() instead of ggplot()
ggmap(corvallis_map_bw) +
  geom_tile(aes(lon, lat, fill = predicted_price), 
            data = preds, alpha = 0.8)
```



# 2. Introducing *sp* objects

Why do we need a new object - *sp*? 

Because Data frames aren't a great way to store spatial data: 

* Need an easy way to keep coordinate reference system information

* Inefficient for complicated spatial objects

* Hierarchical structure gets forced into a flat structure 


The *sp* package: 

* provides classes for storing different types of spatial data

* provides methods for spatial objects, for manipulation

* is useful for point, line and polygon data 

* is a standard, so new spatial packages expect data in an *sp* object 


## 2.1 A spatial object - take a look 

```{r}
library(sp)

countries_sp <- read_rds("data/02_countries_sp.rds")

# Print countries_sp
# print(countries_sp)
class(countries_sp)


# Call summary() on countries_sp
summary(countries_sp)

# Call plot() on countries_sp
plot(countries_sp)
```


## 2.2 Waht's inside a spatial object? 

```{r}
# Call str() on countries_sp
#str(countries_sp)

# Call str() on countries_sp with max.level = 2
str(countries_sp, max.level = 2)
```


##  2.3 A more complicated spatial object

```{r}
# read data 
countries_spdf <- read_rds("data/02_countries_spdf.rds")

# Call summary() on countries_spdf and countries_sp
summary(countries_spdf)
summary(countries_sp)

# Call str() with max.level = 2 on countries_spdf
str(countries_spdf, max.level = 2)

# Plot countries_spdf
plot(countries_spdf)
```


## 2.4 Waling the hierarchy 

```{r}
# 169th element of countries_spdf@polygons: one
one <- countries_spdf@polygons[[169]]

# Print one
#one 

# Call summary() on one
summary(one)

# Call str() on one with max.level = 2
str(one, max.level = 2)


# str() with max.level = 2, on the Polygons slot of one
str(one@Polygons, max.level = 2)

# str() with max.level = 2, on the 6th element of the one@Polygons
str(one@Polygons[[6]])

# Call plot on the coords slot of 6th element of one@Polygons
plot(one@Polygons[[6]]@coords)


```


## 2.5 Subsetting by index

```{r}
# Subset the 169th object of countries_spdf: usa
usa <- countries_spdf[1, ]

# Look at summary() of usa
summary(usa)

# Look at str() of usa
str(usa, max.level = 2)

# Call plot() on usa
plot(usa)
```

## 2.6 Accessing data in sp objects 

```{r}
# Call head() and str() on the data slot of countries_spdf
head(countries_spdf@data)
str(countries_spdf@data)

# Pull out the name column using $
countries_spdf$name

# Pull out the subregion column using [[
countries_spdf[["subregion"]]
```


## 2.7 Subsetting based on data attributes

```{r}
# Create logical vector: is_nz
is_nz <- countries_spdf$name == "New Zealand"

# Subset countries_spdf using is_nz: nz
nz <- countries_spdf[is_nz, ]

# Plot nz
plot(nz)
```


## 2.7 tmap, a package that works with sp objects

```{r}
library(sp)
library(tmap)

# Use qtm() to create a choropleth map of gdp
qtm(shp = countries_spdf, fill = "gdp")

# Use qtm() to create a choropleth map of population
qtm(shp = countries_spdf, fill = "population")
```


## 2.8 Building a plot in layers

```{r}
# Add style argument to the tm_fill() call
tm_shape(countries_spdf) +
  tm_fill(col = "population", style = "quantile") +
    # Add a tm_borders() layer 
    tm_borders(col = "burlywood4")
  

# New plot, with tm_bubbles() instead of tm_fill()
tm_shape(countries_spdf) +
  tm_bubbles(size = "population", style = "quantile") +
    # Add a tm_borders() layer 
    tm_borders(col = "burlywood4")
```

## 2.9 Projection 

```{r}

# Switch to a Hobo–Dyer projection , designed to preserve area.
tm_shape(countries_spdf, projection = "hd") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") 

# Switch to a Robinson projection designed as a compromise between preserving local angles and area.
tm_shape(countries_spdf, projection = "robin") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") 

# Add tm_style_classic() to your plot

tm_shape(countries_spdf, projection = "robin") +
  tm_grid(n.x = 11, n.y = 11) +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4") +
  tm_style_classic()

```


## 2.10 Save a tmap plot: static and interactive maps

```{r}

# Plot from last exercise
my_map <- tm_shape(countries_spdf) +
  tm_grid(n.x = 11, n.y = 11, projection = "longlat") +
  tm_fill(col = "population", style = "quantile")  +
  tm_borders(col = "burlywood4")

my_map

# Save a static version "population.png"
save_tmap(tm = my_map, filename = "population.png")

# Save an interactive version "population.html"
save_tmap(my_map, filename = "population.html")
```



# 4. Data Import and Projections 

In this chapter you'll follow the creation of a visualization from raw spatial data files to adding a credit to a map. Along the way, you'll learn how to read spatial data into R, more about projections and coordinate reference systems, how to add additional data to a spatial object, and some tips for polishing your maps.

## 4.1 Reading in a shapefile 

*Shapefiles* are one of the most common ways spatial data are shared and are easily read into R using *readOGR()* from the *rgdal* package. *readOGR()* has two important arguments: *dsn* and *layer*. Exactly what you pass to these arguments depends on what kind of data you are reading in. You learned in the video that for shapefiles, dsn should be the path to the directory that holds the files that make up the shapefile and layer is the file name of the particular shapefile (without any extension).

For your map, you want neighborhood boundaries. We downloaded the Neighborhood Tabulation Areas, as defined by the City of New York, from the Open Data Platform of the Department of City Planning. The download was in the form of a zip archive and we have put the result of unzipping the downloaded file in your working directory.

You'll use the dir() function from base R to examine the contents of your working directory, then read in the shapefile to R.

```{r}
library(sp)
library(rgdal)
library(sf)

# Use dir() to find directory name
dir()

# Call dir() with directory name
dir("data/nynta_19a")

# Read in shapefile with readOGR(): neighborhoods
neighborhoods <- readOGR("data/nynta_19a", "nynta")

# using the package of sf
neighborhoods_2 <- sf::st_read("data/nynta_19a/nynta.shp")


# summary() of neighborhoods
summary(neighborhoods)
summary(neighborhoods_2)

# Plot neighboorhoods
plot(neighborhoods)
# Plot the same data imported using sf::st_read
plot(neighborhoods_2)

# Plot just the geometry of big_parks
plot(st_geometry(neighborhoods_2))
```

## 4.2 Reading in a raster file

Raster files are most easily read in to R with the *raster()* function from the *raster* package. You simply pass in the filename (including the extension) of the raster as the first argument, x.

The *raster()* function uses some native raster package functions for reading in certain file types (based on the extension in the file name) and otherwise hands the reading of the file on to *readGDAL()* from the *rgdal* package. The benefit of not using *readGDAL()* directly is simply that *raster()* returns a RasterLayer object.

A common kind of raster file is the GeoTIFF, with file extension .tif or .tiff. 

```{r}
library(raster) 

# Call dir()
dir("data")

# Use raster() with file path: income_grid
income_grid <- raster::raster("data/m5602ahhi00.tif")

# Call summary() on income_grid
summary(income_grid)

# Call plot() on income_grid
plot(income_grid)
```

## 4.3 Getting data using a package

Reading in spatial data from a file is one way to get spatial data into R, but there are also some packages that provide commonly used spatial data. For example, the *rnaturalearth* package provides data from Natural Earth, a source of high resolution world maps including coastlines, states, and populated places. In fact, this was the source of the data from Chapter 2.

You will be examining median income at the census tract level in New York County (a.k.a. the Bourough of Manhattan), but to do this you'll need to know the boundaries of the census tracts. The *tigris* package in R provides a way to easily download and import shapefiles based on US Census geographies. You'll use the *tracts()* function to download tract boundaries, but *tigris* also provides *states()*, *counties()*, *places()* and many other functions that match the various levels of geographic entities defined by the Census.

Let's grab the spatial data for the tracts.

```{r}
library(sp)
library(tigris)

# Call tracts(): nyc_tracts
nyc_tracts <- tracts(state = "NY", county = "New York", cb = TRUE)

alameda_tracts <- tracts(state = "CA", county = "Alameda", cb = TRUE)

# Call summary() on nyc_tracts
summary(nyc_tracts)

# Plot nyc_tracts
plot(nyc_tracts)

# Plot Alameda County, CA
plot(alameda_tracts)
```

In case you were wondering, the final argument cb = TRUE downloads the lower resolution boundaries which makes for a quicker download.


## 4.4 Merging data from different CRS/projections

Every spatial object has a coordinate reference system (CRS) associated with it. Generally, this is set when the data are imported and will be read directly from the spatial files. This is how the *neighborhoods* and *nyc_tracts* obtained their coordinate system information.

Both the *sp* and *raster* packages have a *proj4string()* function that returns the CRS of the object it's called on.

Trying to work with spatial data using different CRSs is a bit like trying to work with a dataset in miles and another in kilometers. They are measuring the same thing, but the numbers aren't directly comparable.

```{r}
library(sp)

# proj4string() on nyc_tracts and neighborhoods
proj4string(nyc_tracts)
proj4string(neighborhoods)


# coordinates() on nyc_tracts and neighborhoods
head(coordinates(nyc_tracts))
head(coordinates(neighborhoods))


# plot() neighborhoods and nyc_tracts
plot(neighborhoods)
plot(nyc_tracts, col = "red", add = TRUE)

```
Why didn't we see the tracts on our plot of neighborhoods? Simply because the coordinates of the tracts put them way off the boundaries of our plot.


## 4.5 Converting from one CRS/projection to another

The process of converting from one CRS or projection to another is handled by the *spTransform()* methods in the *rgdal* package. *spTransform()* has methods for all *sp* objects including *SpatialPolygonsDataFrame*, but doesn't work on *raster* objects. This is because transforming a *raster* is a little more complicated; the transformed rectangular grid will no longer be rectangular. You can look at *?raster::projectRaster* if you are curious about transforming rasters.

Transformation is simple. The first argument to *spTransform()*, x, is the spatial object to be transformed and the second, CRS, is a specification of the desired *CRS*. The CRS can be specified by a PROJ4 string, which you could construct by hand, but it's much easier to take it from an existing object (e.g. with the *proj4string()* function).

Time to get your two polygons datasets into the same CRS.

```{r}
library(sp)
library(raster)

# Use spTransform on neighborhoods: neighborhoods
spTransform(neighborhoods, proj4string(nyc_tracts))


# head() on coordinates() of neighborhoods
head(neighborhoods)
coordinates(neighborhoods)

data(water)

# Plot neighborhoods, nyc_tracts and water
plot(neighborhoods)
plot(nyc_tracts, add = TRUE, col = "red")
plot(water, add = TRUE, col = "blue")
```

## 4.6 The wrong way

When a *Spatial***DataFrame* object is created, there are two ways the spatial objects (e.g. Polygons) might be matched up to the rows of the data. The most robust is to use IDs on the spatial objects that are matched up to row names in the data. This ensures if there are any that don't match you are quickly alerted. The other way is simply by order -- the first spatial object is assumed to correspond to the first row of data.

Once created, the correspondence is based purely on order. If you manipulate the data slot, there is no checking the spatial objects still correspond to the right rows. What does this mean in practice? It's very dangerous to manipulate the data slot directly!

To create your plot of income, you need to match up the income data frame with the tracts SpatialPolygonsDataFrame. To illustrate the danger of manipulating @data directly, let's see what happens if you try to force nyc_income in to nyc_tracts.


```{r}
library(sp)

# Use str() on nyc_income 
data("nyc_income")
str(nyc_income)

# ...and on nyc_tracts@data
str(nyc_tracts@data)

# Highlight tract 002201 in nyc_tracts
plot(nyc_tracts)
plot(nyc_tracts[nyc_tracts$TRACTCE == "002201", ], 
     col = "red", add = TRUE)



```

