---
title: "Intermediate R"
author: "Jeff Li"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: true
    toc_depth: 3
    toc_float: true
---

"I maintained my edge by always being a student; you will always have something new to learn". - Jackie Joyner Kersee



**Course Description**

"The intermediate R course is the logical next stop on your journey in the R programming language. In this R training you will learn about conditional statements, loops and functions to power your own R scripts. Next, you can make your R code more efficient and readable using the apply functions. Finally, the utilities chapter gets you up to speed with regular expressions in the R programming language, data structure manipulations and times and dates. This R tutorial will allow you to learn R and take the next step in advancing your overall knowledge and capabilities while programming in R." 


Ref: Schouwenaars, Flips. https://www.datacamp.com/courses/intermediate-r, 2018.


Note: Some course materials have been adapted for internal R training. 


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## (I) Load Required Libraries
```{r, message = FALSE}
library(tidyverse)
```

# 1.  Conditional and Control Flow 

# 2. Loops 

# 3. Functions

# 4. Teh apply family 



# 5. Utilities 

## 5.1 Mathematical Utilities

```{r}
# The errors vector has already been defined for you
errors <- c(1.9, -2.6, 4.0, -9.5, -3.4, 7.3)

# Sum of absolute rounded values of errors
sum(round(abs(errors)))

# Don't edit these two lines
vec1 <- c(1.5, 2.5, 8.4, 3.7, 6.3)
vec2 <- rev(vec1)    # reverse elements

# Fix the error
mean(c(abs(vec1), abs(vec2)))


```

## 5.2 Data Utilities

R features a bunch of functions to juggle around with data structures::

* seq(): Generate sequences, by specifying the from, to, and by arguments.

* rep(): Replicate elements of vectors and lists.

* sort(): Sort a vector in ascending order. Works on numerics, but also on character strings and logicals.

* rev(): Reverse the elements in a data structures for which reversal is defined.

* str(): Display the structure of any R object.

* append(): Merge vectors or lists.

* is.*(): Check for the class of an R object.

* as.*(): Convert an R object from one class to another.

* unlist(): Flatten (possibly embedded) lists to produce a vector.

```{r}
# The linkedin and facebook lists have already been created for you
linkedin <- list(16, 9, 13, 5, 2, 17, 14)
facebook <- list(17, 7, 5, 16, 8, 13, 14)

# Convert linkedin and facebook to a vector: li_vec and fb_vec
li_vec <- unlist(linkedin)
fb_vec <- unlist(facebook)

# Append fb_vec to li_vec: social_vec
social_vec <- append(li_vec, fb_vec)

# Sort social_vec
sort(social_vec, decreasing = TRUE)


# Create first sequence: seq1
seq1 <- seq(from = 1, to = 500, by = 3)

# Create second sequence: seq2
seq2 <- seq(from = 1200, to = 900, by = -7)

# Calculate total sum of the sequences

sum(c(seq1, seq2))
```


## 5.3 Regular Expressions 

* grepl(), which returns TRUE when a pattern is found in the corresponding character string.

* grep(), which returns a vector of indices of the character strings that contains the pattern.

```{r}
# The emails vector has already been defined for you
emails <- c("john.doe@ivyleague.edu", "education@world.gov", "dalai.lama@peace.org",
            "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

# Use grepl() to match for "edu"
grepl(pattern = "edu", x = emails)

# Use grep() to match for "edu", save result to hits
hits <- grep(pattern = "edu", x = emails)
hits


# subset emails using hits

emails[hits]

```

```{r}
# The emails vector has already been defined for you
emails <- c("john.doe@ivyleague.edu", "education@world.gov", "dalai.lama@peace.org",
            "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

# Use grepl() to match for .edu addresses more robustly

grepl(pattern = "@.*\\.edu$", emails)

# Use grep() to match for .edu addresses more robustly, save result to hits
hits <- grep(pattern = "@.*\\.edu$", x = emails)

# Subset emails using hits
emails[hits]

```

## 5.4 sub & gsub

* sub() only replaces the first match

* gsub() replaces all matches.

```{r}
# The emails vector has already been defined for you
emails <- c("john.doe@ivyleague.edu", "education@world.gov", "global@peace.org",
            "invalid.edu", "quant@bigdatacollege.edu", "cookie.monster@sesame.tv")

# Use sub() to convert the email domains to datacamp.edu

sub(pattern = "@.*\\.edu$", replacement = "@datacamp.edu", x = emails )
```


## 5.5 Times and Dates

```{r}
# Get the current date: today
today <- Sys.Date()

# See what today looks like under the hood
today
unclass(today)


# Get the current time: now
now <- Sys.time()

# See what now looks like under the hood
now
unclass(now)
```

* %Y: 4-digit year (1982)

* %y: 2-digit year (82)

* %m: 2-digit month (01)

* %d: 2-digit day of the month (13)

* %A: weekday (Wednesday)

* %a: abbreviated weekday (Wed)

* %B: month (January)

* %b: abbreviated month (Jan)

```{r}
# Definition of character strings representing dates
str1 <- "May 23, '96"
str2 <- "2012-03-15"
str3 <- "30/January/2006"

# Convert the strings to dates: date1, date2, date3
date1 <- as.Date(str1, format = "%b %d, '%y")
date2 <- as.Date(str2, format = "%Y-%m-%d")
date3 <- as.Date(str3, format = "%d/%B/%Y")

# Convert dates to formatted strings
format(date1, "%A")
format(date2, "%d")
format(date3, "%b %Y")

```

## 5.6 Create and format times

Similar to working with dates, you can use as.POSIXct() to convert from a character string to a POSIXct object, and format() to convert from a POSIXct object to a character string. Again, you have a wide variety of symbols:

* %H: hours as a decimal number (00-23)

* %I: hours as a decimal number (01-12)

* %M: minutes as a decimal number

* %S: seconds as a decimal number

* %T: shorthand notation for the typical format %H:%M:%S

* %p: AM/PM indicator

```{r}
# Definition of character strings representing times
str1 <- "May 23, '96 hours:23 minutes:01 seconds:45"
str2 <- "2012-3-12 14:23:08"

# Convert the strings to POSIXct objects: time1, time2
time1 <- as.POSIXct(str1, format = "%B %d, '%y hours:%H minutes:%M seconds:%S")
time2 <- as.POSIXct(str2, format = "%Y-%m-%d %T")

# Convert times to formatted strings
format(time1, "%M")
format(time2, "%I:%M %p")

```

```{r}
astro <- c(spring = "20-Mar-2015", summer = "25-Jun-2015", fall = "23-Sep-2015", winter = "22-Dec-2015")

meteo <- c(spring = "March 1, 15", summer = "June 1, 15", fall = "September 1, 15", Winter = "December 1, 15")

# Convert astro to vector of Date objects: astro_dates
astr_data <- as.Date(astro, format = "%d-%b-%Y")

# Convert meteo to vector of Date objects: meteo_dates
meteo_dates <- as.Date(meteo, format = "%B %d, %y")

# Calculate the maximum absolute difference between astro_dates and meteo_dates

max(abs(astr_data - meteo_dates))



```


